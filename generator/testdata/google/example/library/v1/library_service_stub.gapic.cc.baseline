// Generated by the GAPIC C++ plugin.
// If you make any local changes, they will be lost.
// source: generator/testdata/library.proto

#include "library_service_stub.gapic.h"
#include "gax/call_context.h"
#include "gax/Status.h"
#include "grpcpp/client_context.h"
#include "grpcpp/channel.h"
#include "grpcpp/create_channel.h"
#include <chrono>
#include <thread>

google::gax::Status
LibraryServiceStub::CreateBook(
  google::gax::CallContext&,
  ::google::example::library::v1::CreateBookRequest const&,
  ::google::example::library::v1::Book*) {
  return google::gax::Status(google::gax::StatusCode::kUnimplemented,
    "CreateBook not implemented");
}

google::gax::Status
LibraryServiceStub::GetBook(
  google::gax::CallContext&,
  ::google::example::library::v1::GetBookRequest const&,
  ::google::example::library::v1::Book*) {
  return google::gax::Status(google::gax::StatusCode::kUnimplemented,
    "GetBook not implemented");
}

google::gax::Status
LibraryServiceStub::ListBooks(
  google::gax::CallContext&,
  ::google::example::library::v1::ListBooksRequest const&,
  ::google::example::library::v1::ListBooksResponse*) {
  return google::gax::Status(google::gax::StatusCode::kUnimplemented,
    "ListBooks not implemented");
}

google::gax::Status
LibraryServiceStub::DeleteBook(
  google::gax::CallContext&,
  ::google::example::library::v1::DeleteBookRequest const&,
  ::google::example::library::v1::Empty*) {
  return google::gax::Status(google::gax::StatusCode::kUnimplemented,
    "DeleteBook not implemented");
}

google::gax::Status
LibraryServiceStub::UpdateBook(
  google::gax::CallContext&,
  ::google::example::library::v1::UpdateBookRequest const&,
  ::google::example::library::v1::Book*) {
  return google::gax::Status(google::gax::StatusCode::kUnimplemented,
    "UpdateBook not implemented");
}

google::gax::Status
LibraryServiceStub::GetBigBook(
  google::gax::CallContext&,
  ::google::example::library::v1::GetBookRequest const&,
  ::google::example::library::v1::Book*) {
  return google::gax::Status(google::gax::StatusCode::kUnimplemented,
    "GetBigBook not implemented");
}

LibraryServiceStub::~LibraryServiceStub() {}

namespace {
class DefaultLibraryServiceStub : public LibraryServiceStub {
 public:
  DefaultLibraryServiceStub(std::unique_ptr<LibraryService::StubInterface> grpc_stub)
    : grpc_stub_(std::move(grpc_stub)) {}

  DefaultLibraryServiceStub(DefaultLibraryServiceStub const&) = delete;
  DefaultLibraryServiceStub& operator=(DefaultLibraryServiceStub const&) = delete;

  google::gax::Status
  CreateBook(google::gax::CallContext& context,
    ::google::example::library::v1::CreateBookRequest const& request,
    ::google::example::library::v1::Book* response) override {
    grpc::ClientContext grpc_ctx;
    context->PrepareGrpcContext(&grpc_ctx);
    return google::gax::GrpcStatusToGaxStatus(grpc_stub_->CreateBook(&grpc_ctx, request, response));
  }

  google::gax::Status
  GetBook(google::gax::CallContext& context,
    ::google::example::library::v1::GetBookRequest const& request,
    ::google::example::library::v1::Book* response) override {
    grpc::ClientContext grpc_ctx;
    context->PrepareGrpcContext(&grpc_ctx);
    return google::gax::GrpcStatusToGaxStatus(grpc_stub_->GetBook(&grpc_ctx, request, response));
  }

  google::gax::Status
  ListBooks(google::gax::CallContext& context,
    ::google::example::library::v1::ListBooksRequest const& request,
    ::google::example::library::v1::ListBooksResponse* response) override {
    grpc::ClientContext grpc_ctx;
    context->PrepareGrpcContext(&grpc_ctx);
    return google::gax::GrpcStatusToGaxStatus(grpc_stub_->ListBooks(&grpc_ctx, request, response));
  }

  google::gax::Status
  DeleteBook(google::gax::CallContext& context,
    ::google::example::library::v1::DeleteBookRequest const& request,
    ::google::example::library::v1::Empty* response) override {
    grpc::ClientContext grpc_ctx;
    context->PrepareGrpcContext(&grpc_ctx);
    return google::gax::GrpcStatusToGaxStatus(grpc_stub_->DeleteBook(&grpc_ctx, request, response));
  }

  google::gax::Status
  UpdateBook(google::gax::CallContext& context,
    ::google::example::library::v1::UpdateBookRequest const& request,
    ::google::example::library::v1::Book* response) override {
    grpc::ClientContext grpc_ctx;
    context->PrepareGrpcContext(&grpc_ctx);
    return google::gax::GrpcStatusToGaxStatus(grpc_stub_->UpdateBook(&grpc_ctx, request, response));
  }

  google::gax::Status
  GetBigBook(google::gax::CallContext& context,
    ::google::example::library::v1::GetBookRequest const& request,
    ::google::example::library::v1::Book* response) override {
    grpc::ClientContext grpc_ctx;
    context->PrepareGrpcContext(&grpc_ctx);
    return google::gax::GrpcStatusToGaxStatus(grpc_stub_->GetBigBook(&grpc_ctx, request, response));
  }

 private:
  std::unique_ptr<::google::example::library::v1::LibraryService::StubInterface> grpc_stub_;
};  // DefaultLibraryServiceStub

class RetryLibraryServiceStub : public LibraryServiceStub {
 public:
  RetryLibraryServiceStub(std::unique_ptr<LibraryServiceStub> stub_,
                         gax::RetryPolicy const& retry_policy,
                         gax::BackoffPolicy const& backoff_policy) :
            next_stub_(std::move(stub)),
            default_retry_policy_(retry_policy.clone()),
            default_backoff_policy_(backoff_policy.clone()) {}

  google::gax::Status
  CreateBook(google::gax::CallContext& context,
             ::google::example::library::v1::CreateBookRequest const& request,
             ::google::example::library::v1::Book& response) override {
    auto retry_policy = clone_retry(context);
    auto backoff_policy = clone_backoff(context);
    gax::MethodInfo info = context.Info();
    while (true) {
      // The next layer stub may add metadata, so create a
      // fresh call context each time through the loop.
      gax::CallContext context_copy(context);
      gax::Status status = next_stub_->CreateBook(context_copy, request, response);
      if (status.IsOk() || !retry_policy->OnFailure(status) ||
          !info.idempotency == gax::MethodInfo::Idempotency::IDEMPOTENT) {
        return status;
      }

      auto delay = backoff_policy->OnCompletion();
      std::this_thread::sleep_for(delay);
    }
  }

  google::gax::Status
  GetBook(google::gax::CallContext& context,
             ::google::example::library::v1::GetBookRequest const& request,
             ::google::example::library::v1::Book& response) override {
    auto retry_policy = clone_retry(context);
    auto backoff_policy = clone_backoff(context);
    gax::MethodInfo info = context.Info();
    while (true) {
      // The next layer stub may add metadata, so create a
      // fresh call context each time through the loop.
      gax::CallContext context_copy(context);
      gax::Status status = next_stub_->GetBook(context_copy, request, response);
      if (status.IsOk() || !retry_policy->OnFailure(status) ||
          !info.idempotency == gax::MethodInfo::Idempotency::IDEMPOTENT) {
        return status;
      }

      auto delay = backoff_policy->OnCompletion();
      std::this_thread::sleep_for(delay);
    }
  }

  google::gax::Status
  ListBooks(google::gax::CallContext& context,
             ::google::example::library::v1::ListBooksRequest const& request,
             ::google::example::library::v1::ListBooksResponse& response) override {
    auto retry_policy = clone_retry(context);
    auto backoff_policy = clone_backoff(context);
    gax::MethodInfo info = context.Info();
    while (true) {
      // The next layer stub may add metadata, so create a
      // fresh call context each time through the loop.
      gax::CallContext context_copy(context);
      gax::Status status = next_stub_->ListBooks(context_copy, request, response);
      if (status.IsOk() || !retry_policy->OnFailure(status) ||
          !info.idempotency == gax::MethodInfo::Idempotency::IDEMPOTENT) {
        return status;
      }

      auto delay = backoff_policy->OnCompletion();
      std::this_thread::sleep_for(delay);
    }
  }

  google::gax::Status
  DeleteBook(google::gax::CallContext& context,
             ::google::example::library::v1::DeleteBookRequest const& request,
             ::google::example::library::v1::Empty& response) override {
    auto retry_policy = clone_retry(context);
    auto backoff_policy = clone_backoff(context);
    gax::MethodInfo info = context.Info();
    while (true) {
      // The next layer stub may add metadata, so create a
      // fresh call context each time through the loop.
      gax::CallContext context_copy(context);
      gax::Status status = next_stub_->DeleteBook(context_copy, request, response);
      if (status.IsOk() || !retry_policy->OnFailure(status) ||
          !info.idempotency == gax::MethodInfo::Idempotency::IDEMPOTENT) {
        return status;
      }

      auto delay = backoff_policy->OnCompletion();
      std::this_thread::sleep_for(delay);
    }
  }

  google::gax::Status
  UpdateBook(google::gax::CallContext& context,
             ::google::example::library::v1::UpdateBookRequest const& request,
             ::google::example::library::v1::Book& response) override {
    auto retry_policy = clone_retry(context);
    auto backoff_policy = clone_backoff(context);
    gax::MethodInfo info = context.Info();
    while (true) {
      // The next layer stub may add metadata, so create a
      // fresh call context each time through the loop.
      gax::CallContext context_copy(context);
      gax::Status status = next_stub_->UpdateBook(context_copy, request, response);
      if (status.IsOk() || !retry_policy->OnFailure(status) ||
          !info.idempotency == gax::MethodInfo::Idempotency::IDEMPOTENT) {
        return status;
      }

      auto delay = backoff_policy->OnCompletion();
      std::this_thread::sleep_for(delay);
    }
  }

  google::gax::Status
  StreamShelves(google::gax::CallContext& context,
             ::google::example::library::v1::StreamShelvesRequest const& request,
             ::google::example::library::v1::StreamShelvesResponse& response) override {
    auto retry_policy = clone_retry(context);
    auto backoff_policy = clone_backoff(context);
    gax::MethodInfo info = context.Info();
    while (true) {
      // The next layer stub may add metadata, so create a
      // fresh call context each time through the loop.
      gax::CallContext context_copy(context);
      gax::Status status = next_stub_->StreamShelves(context_copy, request, response);
      if (status.IsOk() || !retry_policy->OnFailure(status) ||
          !info.idempotency == gax::MethodInfo::Idempotency::IDEMPOTENT) {
        return status;
      }

      auto delay = backoff_policy->OnCompletion();
      std::this_thread::sleep_for(delay);
    }
  }

  google::gax::Status
  DiscussBook(google::gax::CallContext& context,
             ::google::example::library::v1::DiscussBookRequest const& request,
             ::google::example::library::v1::Comment& response) override {
    auto retry_policy = clone_retry(context);
    auto backoff_policy = clone_backoff(context);
    gax::MethodInfo info = context.Info();
    while (true) {
      // The next layer stub may add metadata, so create a
      // fresh call context each time through the loop.
      gax::CallContext context_copy(context);
      gax::Status status = next_stub_->DiscussBook(context_copy, request, response);
      if (status.IsOk() || !retry_policy->OnFailure(status) ||
          !info.idempotency == gax::MethodInfo::Idempotency::IDEMPOTENT) {
        return status;
      }

      auto delay = backoff_policy->OnCompletion();
      std::this_thread::sleep_for(delay);
    }
  }

  google::gax::Status
  MonologAboutBook(google::gax::CallContext& context,
             ::google::example::library::v1::DiscussBookRequest const& request,
             ::google::example::library::v1::Comment& response) override {
    auto retry_policy = clone_retry(context);
    auto backoff_policy = clone_backoff(context);
    gax::MethodInfo info = context.Info();
    while (true) {
      // The next layer stub may add metadata, so create a
      // fresh call context each time through the loop.
      gax::CallContext context_copy(context);
      gax::Status status = next_stub_->MonologAboutBook(context_copy, request, response);
      if (status.IsOk() || !retry_policy->OnFailure(status) ||
          !info.idempotency == gax::MethodInfo::Idempotency::IDEMPOTENT) {
        return status;
      }

      auto delay = backoff_policy->OnCompletion();
      std::this_thread::sleep_for(delay);
    }
  }

  google::gax::Status
  GetBigBook(google::gax::CallContext& context,
             ::google::example::library::v1::GetBookRequest const& request,
             ::google::example::library::v1::Book& response) override {
    auto retry_policy = clone_retry(context);
    auto backoff_policy = clone_backoff(context);
    gax::MethodInfo info = context.Info();
    while (true) {
      // The next layer stub may add metadata, so create a
      // fresh call context each time through the loop.
      gax::CallContext context_copy(context);
      gax::Status status = next_stub_->GetBigBook(context_copy, request, response);
      if (status.IsOk() || !retry_policy->OnFailure(status) ||
          !info.idempotency == gax::MethodInfo::Idempotency::IDEMPOTENT) {
        return status;
      }

      auto delay = backoff_policy->OnCompletion();
      std::this_thread::sleep_for(delay);
    }
  }

 private:
  std::unique_ptr<gax::RetryPolicy>
  clone_retry(gax::CallContext const &context) const {
    auto context_retry = context.RetryPolicy();
    return context_retry ? context_retry
                         : default_retry_policy_->clone();
  }

  std::unique_ptr<gax::BackoffPolicy>
  clone_backoff(gax::CallContext const &context) const {
    auto context_backoff = context.BackoffPolicy();
    return context_backoff ? context_backoff
                           : default_backoff_policy_->clone();
  }

  std::unique_ptr<LibraryServiceStub> next_stub_;
  const std::unique_ptr<gax::RetryPolicy const> default_retry_policy_;
  const std::unique_ptr<gax::BackoffPolicy const>  default_backoff_policy_;
};  // RetryLibraryServiceStub
}  // namespace

std::unique_ptr<LibraryServiceStub> CreateLibraryServiceStub() {
  auto credentials = grpc::GoogleDefaultCredentials();
  return CreateLibraryServiceStub(std::move(credentials));
}

std::unique_ptr<LibraryServiceStub>
CreateLibraryServiceStub(std::shared_ptr<grpc::ChannelCredentials> creds) {
  auto channel = grpc::CreateChannel("library.googleapis.com",
    std::move(creds));
  auto grpc_stub = ::google::example::library::v1::LibraryService::NewStub(std::move(channel));
  auto default_stub = std::unique_ptr<LibraryServiceStub>(new 
    DefaultLibraryServiceStub(std::move(grpc_stub)));
  using ms = std::chrono::milliseconds;
  // Note: these retry and backoff times are dummy stand ins.
  // More appopriate default values will be chosen later.
  return std::unique_ptr<LibraryServiceStub>(new RetryLibraryServiceStub(
                       std::move(default_stub),
                       gax::LimitedDurationRetryPolicy(ms(500)),
                       gax::ExponentialBackoffPolicy(ms(20), ms(100))));
}


// Generated by the GAPIC C++ plugin.
// If you make any local changes, they will be lost.
// source: generator/testdata/library.proto
#include <string>
#include <thread>
#include "library_service.gapic.h"
#include "library_service_stub.gapic.h"
#include "gax/status.h"
#include "gax/status_or.h"

gax::StatusOr<::google::example::library::v1::Book>
LibraryService::CreateBook(
::google::example::library::v1::CreateBookRequest const& request) {
  // TODO: update metadata and idempotency, etc.
  grpc::ClientContext context;
  ::google::example::library::v1::Book response;
  grpc::Status status = stub_->CreateBook(&context, request, &response);

  if (status.ok()) {
    return response;
  }

  std::string error_message;
  // TODO: use idempotency policy to determine whether a failure is permanent
  if (!isPermanentFailure(status)) {
    auto retry_policy = retry_policy_->clone();
    auto backoff_policy = backoff_policy_->clone();
    while (retry_policy->OnFailure(status)) {
      auto backoff_duration = backoff_policy->OnCompletion();
      std::this_thread::sleep_for(backoff_duration);
      status = stub_->CreateBook(&context, request, &response);
      if (status.ok()) {
        return response;
      }
    // TODO: augment error_message with result from status
    }
  }
  // TODO: implement grpcStatusCodeToGaxStatusCode
  gax::StatusCode code = grpcStatusCodeToGaxStatusCode(status.error_code());
  return gax::Status(code, error_message);
}

gax::StatusOr<::google::example::library::v1::Book>
LibraryService::GetBook(
::google::example::library::v1::GetBookRequest const& request) {
  // TODO: update metadata and idempotency, etc.
  grpc::ClientContext context;
  ::google::example::library::v1::Book response;
  grpc::Status status = stub_->GetBook(&context, request, &response);

  if (status.ok()) {
    return response;
  }

  std::string error_message;
  // TODO: use idempotency policy to determine whether a failure is permanent
  if (!isPermanentFailure(status)) {
    auto retry_policy = retry_policy_->clone();
    auto backoff_policy = backoff_policy_->clone();
    while (retry_policy->OnFailure(status)) {
      auto backoff_duration = backoff_policy->OnCompletion();
      std::this_thread::sleep_for(backoff_duration);
      status = stub_->GetBook(&context, request, &response);
      if (status.ok()) {
        return response;
      }
    // TODO: augment error_message with result from status
    }
  }
  // TODO: implement grpcStatusCodeToGaxStatusCode
  gax::StatusCode code = grpcStatusCodeToGaxStatusCode(status.error_code());
  return gax::Status(code, error_message);
}

gax::StatusOr<::google::example::library::v1::ListBooksResponse>
LibraryService::ListBooks(
::google::example::library::v1::ListBooksRequest const& request) {
  // TODO: update metadata and idempotency, etc.
  grpc::ClientContext context;
  ::google::example::library::v1::ListBooksResponse response;
  grpc::Status status = stub_->ListBooks(&context, request, &response);

  if (status.ok()) {
    return response;
  }

  std::string error_message;
  // TODO: use idempotency policy to determine whether a failure is permanent
  if (!isPermanentFailure(status)) {
    auto retry_policy = retry_policy_->clone();
    auto backoff_policy = backoff_policy_->clone();
    while (retry_policy->OnFailure(status)) {
      auto backoff_duration = backoff_policy->OnCompletion();
      std::this_thread::sleep_for(backoff_duration);
      status = stub_->ListBooks(&context, request, &response);
      if (status.ok()) {
        return response;
      }
    // TODO: augment error_message with result from status
    }
  }
  // TODO: implement grpcStatusCodeToGaxStatusCode
  gax::StatusCode code = grpcStatusCodeToGaxStatusCode(status.error_code());
  return gax::Status(code, error_message);
}

gax::StatusOr<::google::example::library::v1::Empty>
LibraryService::DeleteBook(
::google::example::library::v1::DeleteBookRequest const& request) {
  // TODO: update metadata and idempotency, etc.
  grpc::ClientContext context;
  ::google::example::library::v1::Empty response;
  grpc::Status status = stub_->DeleteBook(&context, request, &response);

  if (status.ok()) {
    return response;
  }

  std::string error_message;
  // TODO: use idempotency policy to determine whether a failure is permanent
  if (!isPermanentFailure(status)) {
    auto retry_policy = retry_policy_->clone();
    auto backoff_policy = backoff_policy_->clone();
    while (retry_policy->OnFailure(status)) {
      auto backoff_duration = backoff_policy->OnCompletion();
      std::this_thread::sleep_for(backoff_duration);
      status = stub_->DeleteBook(&context, request, &response);
      if (status.ok()) {
        return response;
      }
    // TODO: augment error_message with result from status
    }
  }
  // TODO: implement grpcStatusCodeToGaxStatusCode
  gax::StatusCode code = grpcStatusCodeToGaxStatusCode(status.error_code());
  return gax::Status(code, error_message);
}

gax::StatusOr<::google::example::library::v1::Book>
LibraryService::UpdateBook(
::google::example::library::v1::UpdateBookRequest const& request) {
  // TODO: update metadata and idempotency, etc.
  grpc::ClientContext context;
  ::google::example::library::v1::Book response;
  grpc::Status status = stub_->UpdateBook(&context, request, &response);

  if (status.ok()) {
    return response;
  }

  std::string error_message;
  // TODO: use idempotency policy to determine whether a failure is permanent
  if (!isPermanentFailure(status)) {
    auto retry_policy = retry_policy_->clone();
    auto backoff_policy = backoff_policy_->clone();
    while (retry_policy->OnFailure(status)) {
      auto backoff_duration = backoff_policy->OnCompletion();
      std::this_thread::sleep_for(backoff_duration);
      status = stub_->UpdateBook(&context, request, &response);
      if (status.ok()) {
        return response;
      }
    // TODO: augment error_message with result from status
    }
  }
  // TODO: implement grpcStatusCodeToGaxStatusCode
  gax::StatusCode code = grpcStatusCodeToGaxStatusCode(status.error_code());
  return gax::Status(code, error_message);
}

gax::StatusOr<::google::example::library::v1::Book>
LibraryService::GetBigBook(
::google::example::library::v1::GetBookRequest const& request) {
  // TODO: update metadata and idempotency, etc.
  grpc::ClientContext context;
  ::google::example::library::v1::Book response;
  grpc::Status status = stub_->GetBigBook(&context, request, &response);

  if (status.ok()) {
    return response;
  }

  std::string error_message;
  // TODO: use idempotency policy to determine whether a failure is permanent
  if (!isPermanentFailure(status)) {
    auto retry_policy = retry_policy_->clone();
    auto backoff_policy = backoff_policy_->clone();
    while (retry_policy->OnFailure(status)) {
      auto backoff_duration = backoff_policy->OnCompletion();
      std::this_thread::sleep_for(backoff_duration);
      status = stub_->GetBigBook(&context, request, &response);
      if (status.ok()) {
        return response;
      }
    // TODO: augment error_message with result from status
    }
  }
  // TODO: implement grpcStatusCodeToGaxStatusCode
  gax::StatusCode code = grpcStatusCodeToGaxStatusCode(status.error_code());
  return gax::Status(code, error_message);
}

